<!-- NOTE:: This uses a cookie to pass the username from the login screen
	    to the client screen. Chrome does not support cookies for local 
	    files. It works in Chrome when deployed, but it must
	    be tested locally in a different browser - no longer true; works locally 
			in chrome if pointed to local server
-->

<html>
  <head>

    <link rel="stylesheet" type="text/css" href="webUI.css">
		<title id="title">AceChat</title>

  </head>

  <body id="body" class="body">
    <div class="left-column">
      <h3>
				Channel List
      </h3>
      <div id="channel-list">
      </div>

      <button class="logout-button"name="logout"type="button" onclick="logout();">LOGOUT</button>
    </div>

    <!--top bar-->
    <div class="top-bar">
		<code id="channel-title"></code>
    </div>

    <!--right -->
    <div class="right">
      <h3>
				Online
      </h3>
      <div id="online-list">
      </div>
			<h2 id="online-channel-header">
			</h2>
			<div id="online-channel-list">
			</div>
    </div>

    <!--center-->
    <div class="center">
			<div id="chat-log-wrapper">
				<div id="chat-log">
				</div>
      </div>

      <div class="textarea">
	>&nbsp
	<div class="textbox">
	  <input type="text"autocomplete="off" placeholder="Say Something!"id="chat-prompt"onkeydown="if(event.keyCode == 13)
											parseInput();"/>
	</div>
	<div class="textbutton">
	  <input type="button" id="textbutton" Value="Send" onclick="parseInput();"/>
	</div>
      </div>

    </div>

  </body>
</html>
  
<script type="text/javascript">
	var server = getCookie("server");
	var focus = true;
	
	if(server == "")
	{
		window.location="login.html";
	}

	var sock = new WebSocket("ws://"+server);

	var userName;

  //current channel
  var channel;

	//store lists retrieved from server
	var usrList = [];
	var chanUsrList = [];

  //channels currently "joined"
  var channels = [];

	//all channels on server
	var chanList = [];

	sock.onopen= function()
	{
		//login with server
		userName = getCookie("user");
		//must be logged in to access this page
		
		if(userName.toLowerCase() == "acechat"|| !userName.match(/^[A-z0-9]{1,10}$/))
		{
			logout();
		}
		var usrMsg = {
										"command" : "USER",
										"args" : [userName]
								 };
		send(usrMsg);

		joinChannel("startHere",welcomeMsg());
		requestUsrList();
		requestChanList();
	};

	sock.onclose = function()
	{
		document.getElementById("body").innerHTML="<p style='color:white'>Failed to connect to server</p><a href='index.html'>Refresh</a><br><a href='login.html'>Return to login</a>";
	};

	function getCookie(cname) 
	{
		var name = cname + "=";
		var ca = document.cookie.split(';');
		for(var i = 0; i <ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0)==' ') {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length,c.length);
			}
		}
		return "";
	} 

	//updates top bar and online-channel-list header
	function updateTopBar()
	{
		document.getElementById("channel-title").innerHTML = channel.name;
		document.getElementById("online-channel-header").innerHTML = channel.name;
	}

	function populateChannelList()
	{
		document.getElementById("channel-list").innerHTML="";
		for(var i=0;i<chanList.length;++i)
		{
			if(chanList[i].name == channel.name)
			{
				var btn = '<button class="channel-button"id="active-channel" onclick="joinChannel(\''+chanList[i].name+'\');"><code>'+chanList[i].name+'</code></button>';
			}
			else
			{
				var btn = '<button class="channel-button" onclick="joinChannel(\''+chanList[i].name+'\');"><code>'+chanList[i].name+'</code></button>';
			}
			document.getElementById("channel-list").innerHTML+=btn+"<br>";
		}
	}

	//define channel as local class
	function channelObj(name)
	{
		this.name = name;
		//messages is a list of JSON object messages from the server.
		//client messages must be wrapped in JSON objects
		this.messages = [];
	}

	function populateOnlineChannelList() 
	{
		document.getElementById("online-channel-list").innerHTML="";
		for(var i=0;i<chanUsrList.length;++i)
		{
			var arg = "'/msg ";
			arg += chanUsrList[i];
			arg+=" '";
			var btn = '<button class="online-button" onclick="getElementById(\'chat-prompt\').value='+arg+'; document.getElementById(\'chat-prompt\').focus();"><code>'+chanUsrList[i]+'</code></button>';
			document.getElementById("online-channel-list").innerHTML+=btn+"<br>";
		}
	}
	
	function populateOnlineList()
	{
		document.getElementById("online-list").innerHTML="";
		for(var i=0;i<usrList.length;++i)
		{
			var arg = "'/msg ";
			arg += usrList[i];
			arg+=" '";
			var btn = '<button class="online-button" onclick="getElementById(\'chat-prompt\').value='+arg+'; document.getElementById(\'chat-prompt\').focus();"><code>'+usrList[i]+'</code></button>';
			document.getElementById("online-list").innerHTML+=btn+"<br>";
		}
	}

	function chanInChanList(s)
	{
		for (var i in chanList)
		{
			if(chanList[i].name == s)
				return i;
		}
		return null;
	}


  //sends object to sever
  function send(e)
  {
		sock.send(JSON.stringify(e));
	}

	//recieve data from server
	sock.onmessage = function(event)
	{
		var msg = JSON.parse(event.data);
		//do something
		switch(msg.command){ 
			case "USERLIST":
				usrList = msg.args;
				populateOnlineList();
				break;
			case "CHANLIST":
				tmp = msg.args;
				for (c in tmp)
				{
					if (chanInChanList(tmp[c]) == null)
					{
						chanList.push(new channelObj(tmp[c]));
					}
				}
				for (c in chanList)
				{
					if (tmp.indexOf(chanList[c].name) == -1)
						chanList.splice(c,1);
				}
				populateChannelList();
				break;
			case "MSG":
				var msgTxt = msg.args[1];
				msgTxt = msgTxt.replace(/</g, "&lt;");
				msgTxt = msgTxt.replace(/>/g, "&gt;");
				msg.args[1] = msgTxt;
				//client protocol messages
				if(msgTxt.substring(0,9) == "\\protocol")
				{
					if(msgTxt.substring(9,12) == "000" & msgTxt.slice(-4) == "\\000")
					{
						//me
						msg.args[1] = msgTxt.slice(12,-4);
						msg.command = "ME";
						msg.args[1] = "*"+msg.user+" "+msg.args[1]+"*";
					}
					else if(msgTxt.substring(9,12) == "001" & msgTxt.slice(-4) == "\\001")
					{
						//PARTY!
						msg.args[1] = msgTxt.slice(12,-4);
						var tmp = msg.args[1];
						var otherTmp="";

						for(var q in tmp)
						{
							otherTmp+= '<div style="display:inline;color:'+randColor()+'">'+tmp[q]+'</div>';
						}
						msg.args[1] = otherTmp;
					}

					else
					{
						//catch invalid protocol messages
						errorHandler("Error -- Invalid Protocol Message");
					}

				}
				channels[getChannel(msg.args[0])].messages.push(msg);
				printChannelMessages(channel);
				break;
			case "PRIVMSG":
				var msgTxt = msg.args[1];
				msgTxt = msgTxt.replace(/</g, "&lt;");
				msgTxt = msgTxt.replace(/>/g, "&gt;");
				msg.args[1] = msgTxt;
				for(var i in channels)
				{
					channels[i].messages.push(msg);
				}
				printChannelMessages(channel);
				break;
			case "JOIN":
				if(channel == channels[getChannel(msg.args[0])])
				{
					chanUsrList = [];
					for(var k = 1; k < msg.args.length;++k)
						chanUsrList.push(msg.args[k]);
					populateOnlineChannelList();
				}
				var tmp =""+msg.user+" JOINED "+msg.args[0];
				msg.user = "AceChat";
				msg.command="SYSTEM";
				msg.args[1]=tmp;
				channels[getChannel(msg.args[0])].messages.push(msg);
				if(channel == channels[getChannel(msg.args[0])])
					printChannelMessages(channels[getChannel(msg.args[0])]);
				break;
			case "PART":
				if(channel == channels[getChannel(msg.args[0])])
				{
					chanUsrList = [];
					for(var k = 1; k < msg.args.length;++k)
						chanUsrList.push(msg.args[k]);
					populateOnlineChannelList();
				}
				var tmp =""+msg.user+" PARTED "+msg.args[0];
				msg.user = "AceChat";
				msg.command="SYSTEM";
				msg.args[1]=tmp;
				channels[getChannel(msg.args[0])].messages.push(msg);
				if(channel == channels[getChannel(msg.args[0])])
					printChannelMessages(channels[getChannel(msg.args[0])]);
				break;
			case "INVITE":
				var tmp = "";
				tmp = "User "+msg.user+" has invited you to channel "+msg.args[0]+"."
				if(channel != channels[getChannel(msg.args[0])])
				{
					joinChannel(msg.args[0]);
					msg = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : [channel.name, tmp],
										"timestamp" : new Date().getTime()/1000
								};
					channel.messages.push(msg);
					printChannelMessages(channel);
				}
				else
				{
					tmp += " But you're already here!";


					msg = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : [channel.name, tmp],
										"timestamp" : new Date().getTime()/1000
								};

					channel.messages.push(msg);
					printChannelMessages(channel);
				}
				break;
			case "ERROR":
				errorHandler(msg.args[0]);
				break;
		}
	};

	window.onload = function focus()
	{
		document.getElementById('chat-prompt').focus();
	};

	window.onfocus = function ()
	{
		focus = true;
		document.getElementById('title').innerHTML="AceChat";
	}

	window.onblur = function ()
	{
		focus = false;

	}
	function randColor() 
	{
    var hex= '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++ ) 
		{
        color += hex[Math.floor(Math.random() * 16)];
    }
    return color;
	}

	//input: channel name (string)
	//output: index of channelObj in channels
	function getChannel(s)
	{
		for(var i in channels)
		{
			if(channels[i].name == s)
				return i;
		}
		return null;
	}


  	//accepts a string containing an error message. 
	//server errors must be deconstructed in the onmessage function
	function errorHandler(e)
	{
		msg = {
						"user" : "AceChat",
						"command" : "ERROR",
						"args" : [channel,e],
						"timestamp" : new Date().getTime()/1000
					};

		channel.messages.push(msg);
		printChannelMessages(channel);
		
	}


	function chanMsg(e)
	{
		var welcome = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : [e.name,"Welcome to "+ e.name],
										"timestamp" : new Date().getTime()/1000
									};
		e.messages.push(welcome);
	}

	function welcomeMsg()
	{
		var welcome = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : ["Default Channel","Welcome to AceChat! Type /help for a list of commands"],
										"timestamp" : new Date().getTime()/1000
									};
		return welcome;
	}

  //gets user list from server, returns as array of strings
  function requestUsrList()
  {
		var msg = {
						"command" : "USERLIST",
						"args" : []
							};
		send(msg);
  }

  //joins the channels specified by a string
	//optional msg
  function joinChannel(e, s="")
  {
		var found = false;
		var tmp;
		for(var i =0;i<channels.length;++i)
		{
			if(channels[i].name == e)
			{
				found = true;
				tmp = channels[i];
			}
		}
		if (!!channels && found)
		{
			channel = tmp;
			updateTopBar();
			populateChannelList();
			channel.messages.push(s);
			printChannelMessages(channel);
		}
		else
		{

			var msg = {
									"command" : "JOIN",
									"args" : [e]
								};
			send(msg);
			tmp = new channelObj(e);
			channels.push(tmp);
			channel = tmp;
			channel.messages.push(s);
			chanMsg(channel);
			updateTopBar();
			populateChannelList();
			printChannelMessages(tmp);
		}
  }

  //leaves the channel specified by a channelObj
  function part(e)
  {
    var msg = {
								"command" : "PART",
								"args" : [e.name]
							};
    send(msg);

		var tmp = channels.indexOf(e);
		if(tmp > -1)
			channels.splice(tmp,1);
		//populateChannelList();
		if(channels.length == 0)
			logout();
		if(channels.indexOf(channel) == -1)
		{
			joinChannel(channels[0].name);
		}
  }

  //invite users to channel
  //args in the form [channel name, user0, user1,..,usern]
  function invite(e)
  {
    var msg = {
								"command" : "INVITE",
								"args" : e
							};
    send(msg);
  }

  function requestChanList()
  {
    var msg = {
								"command" : "CHANLIST",
								"args" : []
							};
    send(msg); 
  }

  function createCookie(name,value,days) 
	{
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toUTCString();
    }
    else 
    {
      var expires = "";
    }
    document.cookie = name+"="+value+expires+"; path=/";
  }

	function help()
	{
		msgTxt =  "Channels are created by joining them and are deleted when they are empty.<br>"; 
		msgTxt += "Channel names may not contain spaces and cannot be longer than 10 characters.<br>";
		msgTxt += "Mandatory arguments to commands are denoted by angle brackets &lt;&gt;<br>";
		msgTxt += "Optional arguments to commands are dentoted by square brackets []<br><br>";

		//join
		msgTxt += "/join &lt;channel&gt;............................join a channe.<br>";

		//part
		msgTxt += "/part [channel]............................leave a channel<br>";

		//logoff
		msgTxt += "/logoff....................................part all channels and quit<br>";

		//logout
		msgTxt += "/logout....................................same as /logoff<br>";

		//msg
		msgTxt += "/msg &lt;UserName&gt; &lt;Message&gt;..................private message a user<br>";

		//whoami
		msgTxt += "/whoami....................................computer aided introspection<br>";

		//invite
		msgTxt += "/invite &lt;user0&gt; [user1]...[usern]..........invite users to the current channel<br>"

		//standard message
		msgTxt += "&lt;message&gt;..................................send message to your current channel<br>";

		//me
		msgTxt += "/me &lt;message&gt;..............................perform an action<br>";

		//party
		msgTxt += "/party &lt;message&gt;...........................throw a party<br>";

		//help
		msgTxt += "/help......................................show this dialog";

		msg = {
						"user" : "AceChat",
						"command" : "SYSTEM",
						"args" : [channel, msgTxt],
						"timestamp" : new Date().getTime()/1000
					};	
		channel.messages.push(msg);
		printChannelMessages(channel);
	}

	
	function logout()
	{
		createCookie("user","",-1);
		sock.close();
		window.location="login.html";
	}

	//param: channelObj
	function printChannelMessages(e)
	{
		document.getElementById("chat-log").innerHTML="";
		if(e.messages)
		{
			for(var i in e.messages)
			{
				if(e.messages[i].args && e.messages[i].args[1])
				{
					var msgHeader="";
					var msgText="";
					var d = new Date(e.messages[i].timestamp*1000);
					var ts = "" + ("0"+d.getHours()).slice(-2)+":"+("0"+d.getMinutes()).slice(-2)+":"+("0"+d.getSeconds()).slice(-2);
					msgHeader += ts+"  ";
					if(e.messages[i].command=="PRIVMSG")
						msgHeader += "[PRV]";
					if(e.messages[i].command=="ERROR")
						msgHeader += "[ERR]";
					if(e.messages[i].command=="SYSTEM")
						msgHeader += "[SYS]";
					msgHeader += e.messages[i].user+" > ";
					msgText += e.messages[i].args[1];

					if(e.messages[i].command=="ME")
					{
						msgHeader='';
					}
					msgHeader = "<div class=\"msgHeader\"><code>"+msgHeader+"</code></div>";
					var sp    = "<div class=\"spacer\"></div>";
					msgText = "<div class=\"msgText\"><code>"+msgText+"</code></div>";

					document.getElementById("chat-log").innerHTML+="<div class=\"msgRow\">"+msgHeader +sp+ msgText+ "</div>";
					document.getElementById("chat-log").innerHTML+="<div class=\"msgRow\"><div class=\"spacer\"><br></div><div class=\"spacer\"><br></div></div>";

				}
			}
			document.getElementById("chat-log-wrapper").scrollTop=document.getElementById("chat-log-wrapper").scrollHeight;
		}

		if(!focus)
		{
			document.getElementById('title').innerHTML="AceChat - New Message!";
		}
	}

  function parseInput()
  {
    var msgTxt = document.getElementById("chat-prompt").value;
    var msgArr = msgTxt.split(" ");
    var msg;
    document.getElementById("chat-prompt").value = "";

    //msg
		if (msgTxt.match(/^\/msg\s*$/) || msgTxt.match(/^\/msg\s+\S+\s*$/)) 
		{
			errorHandler("/msg must accept at least two arguments");
		}
    //if input begins with /msg validUsrName, send private message
		else if (msgTxt.match(/^\/msg(\s)+/) && !!~usrList.indexOf(msgArr[1]))
    {
      msgArr.shift();
			u = msgArr[0];
      msgArr.shift();
      msgTxt = msgArr.join(" ");
      msg = {
							"command" : "PRIVMSG",
							"args" : [u,msgTxt]
						};
      send(msg);

			msg = {
							"user" : "[PRV] -> "+u,
							"command" : "MSG",
							"args" : [channel.name, msgTxt],
							"timestamp" : new Date().getTime()/1000
						};
			channel.messages.push(msg);
			printChannelMessages(channel);
    }

		//if input begins with /msg invalidUsrName, throw error
		else if (msgTxt.match(/^\/msg(\s|$)/) && !~usrList.indexOf(msgArr[1]))
    {
			errorHandler("Invalid User Name");
    }

		//join
		else if(msgTxt.match(/^\/join\s+[A-z0-9]{1,10}$/))
		{
			msgArr.shift();
			arr = msgArr.join(" ").match(/[^<>]+/);
			joinChannel(arr[0].trim());
		}
		else if(msgTxt.match(/^\/join\s*$/)) 
		{
			errorHandler("/join must accept at least one argument");
		}
		else if(msgTxt.match(/^\/join\s+/)) 
		{
			errorHandler("Invalid channel name");
		}
		
		//part
		else if(msgTxt.match(/^\/part\s+\S+[.]*/))
		{
			msgArr.shift();
			arr = msgArr.join(" ").trim();
			if(channels[getChannel(arr)] != null)
			{
				part(channels[getChannel(arr)]);
			}
			else
				errorHandler("You are not in that channel");
		}
		//part with no args should leave the current channel
		else if(msgTxt.match(/^\/part\s*$/))
		{
			part(channel);
		}

    //logout, logoff
    //**parts all channels**, logs out
		//ideally would part all channels, but it doesn't, and that's okay too.
    else if (msgTxt.match(/^\/logoff(\s|$)/) || msgTxt.match(/^\/logout(\s|$)/))
    {
			logout();
    }

		//whoami
		else if (msgTxt.match(/^\/whoami\s*/))
		{
			msg = {
							"user" : "AceChat",
							"command" : "SYSTEM",
							"args" : [channel.name, userName],
							"timestamp" : new Date().getTime()/1000
						};
			channel.messages.push(msg);
			printChannelMessages(channel);
		}

		//invite with one or more valid usernames
		//tolerates invalid usernames as long as at least one is valid
		else if (msgTxt.match(/^\/invite\s\S+/))
		{
			var atLeastOneValid = false;
			var atLeastOneInvalid = false;
			var sentTo =[];
			msgArr.shift();
			var u =msgArr;
			msgTxt="";

			for (var i in u)
			{
				if(!!~usrList.indexOf(u[i]) && u[i] != userName)
				{
					sentTo.push(u[i]);
					atLeastOneValid = true;
				}
				else
				{
					atLeastOneInvalid = true;
				}
			}

			if(atLeastOneValid)
			{
				if(!atLeastOneInvalid)
				{
					msgTxt = "Successfully invited [";
					for (var i in sentTo)
					{
						msgTxt += sentTo[i];
						msgTxt += ", ";
					}
					msgTxt = msgTxt.slice(0,-2);
					msgTxt += "] to "+channel.name+".";
					msg = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : [channel.name, msgTxt],
										"timestamp" : new Date().getTime()/1000
								};
					channel.messages.push(msg);
					printChannelMessages(channel);
					sentTo.unshift(channel.name)
					invite(sentTo);
				}
				else
				{
					msgTxt = "Successfully invited [";
					for (var i in sentTo)
					{
						msgTxt += sentTo[i];
						msgTxt += ", ";
					}
					msgTxt = msgTxt.slice(0,-2);
					msgTxt +="] to "+channel.name+". Some users could not be invited.";
					msg = {
										"user" : "AceChat",
										"command" : "SYSTEM",
										"args" : [channel.name, msgTxt],
										"timestamp" : new Date().getTime()/1000
								};
					channel.messages.push(msg);
					printChannelMessages(channel);
					sentTo.unshift(channel.name)
					invite(sentTo);
				}
			}
			else
			{
				errorHandler("Invitation failed");
			}

		}

		//invite with no args
		//fails
		else if (msgTxt.match(/^\/invite(\s)*$/))
		{
			errorHandler("/invite must accept at least one argument");
		}

		//help
		else if (msgTxt.match(/^\/help\s*/))
		{
			help();
		}

		//me
		else if (msgTxt.match(/^\/me\s+\S+/))
		{
			msgArr.shift();
			msgTxt = msgArr.join(" ");
			msgTxt = "\\protocol000"+msgTxt+"\\000";
      msg = {
              "command" : "MSG",
							"args" : [channel.name, msgTxt]
						};
      send(msg);
		}
		else if (msgTxt.match(/^\/me\s*$/))
		{
			errorHandler("/me must accept at least one argument");
		}

		//party!
		else if (msgTxt.match(/^\/party\s+\S+/))
		{
			msgArr.shift();
			msgTxt = msgArr.join(" ");
			msgTxt = "\\protocol001"+msgTxt+"\\001";
      msg = {
              "command" : "MSG",
							"args" : [channel.name, msgTxt]
						};
      send(msg);
		}
		else if (msgTxt.match(/^\/party\s*$/))
		{
			errorHandler("You need more arguments to party!");
		}
		
		//invalid command
		else if (msgTxt.match(/^\/.*/) || msgTxt.match(/^\\.*/))
		{
			errorHandler("Invalid Command");
		}

	  //default, send message to current channel
    else if (msgTxt != "" && msgTxt != null)
		{
      msg = {
              "command" : "MSG",
							"args" : [channel.name, msgTxt]
						};
      send(msg);
    }
  }

</script>
